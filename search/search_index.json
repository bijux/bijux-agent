{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bijux Agent","text":"<p>Bijux Agent is a deterministic, auditable document-processing pipeline (CLI + optional HTTP API) designed to:</p> <ul> <li>process files or inline text,</li> <li>produce structured outputs,</li> <li>emit an audit trace suitable for replay validation and post-hoc inspection.</li> </ul>"},{"location":"#quickstart-cli","title":"Quickstart (CLI)","text":"<pre><code>make bootstrap\nexport OPENAI_API_KEY=...\nexport ANTHROPIC_API_KEY=...\nexport HUGGINGFACE_API_KEY=...\nexport DEEPSEEK_API_KEY=...\n\npython -m bijux_agent.main run path/to/file.txt --out artifacts/run1 --config config/config.yml\n</code></pre>"},{"location":"#where-to-start","title":"Where to start","text":"<ul> <li>Using the tool: <code>docs/user/usage.md</code></li> <li>Understanding the model: <code>docs/overview/concepts.md</code></li> <li>Relying on guarantees: <code>docs/spec/read_this_first.md</code></li> <li>Maintaining the repo: <code>docs/maintainer/spec.md</code></li> </ul>"},{"location":"#documentation-invariant-checksum-tracked","title":"Documentation invariant (checksum-tracked)","text":"<p>Docs are treated as part of the runtime contract. Every markdown file under <code>docs/</code> is tracked by checksum and enforced by tests.</p> Tracked documentation files (checksum-enforced)  - docs/api/index.md \u2014 API (v1)   - docs/architecture/ARCHITECTURE.md \u2014 Architecture   - docs/design/determinism.md \u2014 Determinism (design notes)   - docs/examples/document-review.md \u2014 Example: document review workflow   - docs/examples/minimal-pipeline.md \u2014 Example: minimal CLI run   - docs/index.md \u2014 Bijux Agent (this page)   - docs/legal/security.md \u2014 Security   - docs/maintainer/CHANGELOG.md \u2014 Maintainer changelog   - docs/maintainer/anti-features.md \u2014 Anti-features (maintainer) - docs/maintainer/breaking_refactor.md \u2014 Breaking refactor policy (maintainer) - docs/maintainer/code-map.md \u2014 Code map - docs/maintainer/docs-parity.md \u2014 Docs \u2194 code parity - docs/maintainer/docs_contract.md \u2014 Documentation contract (maintainer) - docs/maintainer/docs_voice.md \u2014 Documentation voice (maintainer) - docs/maintainer/docstring-policy.md \u2014 Docstring policy (maintainer) - docs/maintainer/documentation-invariant.md \u2014 Documentation invariant (maintainer) - docs/maintainer/evaluation.md \u2014 Evaluation (maintainer) - docs/maintainer/first-refactor-plan.md \u2014 First refactor plan (maintainer) - docs/maintainer/pipeline_refactor_rules.md \u2014 Pipeline refactor rules (maintainer) - docs/maintainer/project_tree.md \u2014 Project tree - docs/maintainer/refactor-invariants.md \u2014 Refactor invariants (maintainer) - docs/maintainer/refactor-plan.md \u2014 Refactor plan (maintainer) - docs/maintainer/refactor-priority.md \u2014 Refactor priority (maintainer) - docs/maintainer/refactor_scope.md \u2014 Refactor scope (maintainer) - docs/maintainer/rejected-designs.md \u2014 Rejected designs (maintainer) - docs/maintainer/shared/glossary.md \u2014 Maintainer glossary - docs/maintainer/shared/structure.md \u2014 Docs structure (maintainer) - docs/maintainer/shared/style.md \u2014 Docs style (maintainer) - docs/maintainer/spec.md \u2014 Maintainer index - docs/maintainer/system-boundaries.md \u2014 System boundaries (maintainer) - docs/maintainer/testing.md \u2014 Testing (maintainer) - docs/maintainer/tooling.md \u2014 Tooling (maintainer) - docs/maintainer/typing-status.md \u2014 Typing status (maintainer) - docs/maintainer/undefined-behavior.md \u2014 Undefined behavior (maintainer) - docs/maintainer/vocabulary.md \u2014 Maintainer vocabulary - docs/overview/concepts.md \u2014 Concepts - docs/overview/readme.md \u2014 Documentation orientation - docs/spec/agents/agent-contract.md \u2014 Agent contract (spec) - docs/spec/agents/agent-output.md \u2014 Agent output expectations (spec) - docs/spec/architecture_diagram.md \u2014 Architecture diagram (spec) - docs/spec/execution_artifacts.md \u2014 Execution artifacts (spec) - docs/spec/execution_contracts.md \u2014 Execution contracts (spec) - docs/spec/execution_guarantees.md \u2014 Execution guarantees (spec) - docs/spec/execution_intent_matrix.md \u2014 Execution intent matrix (spec) - docs/spec/execution_lifecycle.md \u2014 Execution lifecycle (spec) - docs/spec/failure_model.md \u2014 Failure model (spec) - docs/spec/failure_semantics.md \u2014 Failure semantics (spec) - docs/spec/identity.md \u2014 Identity and versioning (spec) - docs/spec/invariants/architecture-invariants.md \u2014 Architecture invariants (spec) - docs/spec/invariants/convergence-guarantees.md \u2014 Convergence guarantees (spec) - docs/spec/invariants/core-invariants.md \u2014 Core invariants (spec) - docs/spec/invariants/determinism.md \u2014 Determinism invariants (spec) - docs/spec/models/deepseek.md \u2014 DeepSeek backend notes - docs/spec/read_this_first.md \u2014 Read this first (spec) - docs/spec/refusals.md \u2014 Refusals and non-features (spec) - docs/spec/system_contract.md \u2014 System contract (spec) - docs/spec/tracing-replay/why-trace-exists.md \u2014 Why tracing exists - docs/spec/vocabulary.md \u2014 Vocabulary (spec) - docs/user/reading_paths.md \u2014 Reading paths - docs/user/usage.md \u2014 Usage"},{"location":"api/","title":"API (v1)","text":"<p>Bijux Agent provides a small HTTP surface meant for embedding the canonical pipeline in other systems.</p>"},{"location":"api/#mounting-into-fastapi","title":"Mounting into FastAPI","text":"<p><code>bijux_agent.httpapi.v1.build_router()</code> returns an <code>APIRouter</code> when FastAPI is installed.</p> <pre><code>from fastapi import FastAPI\nfrom bijux_agent.httpapi.v1 import build_router\n\napp = FastAPI()\nrouter = build_router()\nif router:\n    app.include_router(router)\n</code></pre>"},{"location":"api/#endpoint-post-v1run","title":"Endpoint: <code>POST /v1/run</code>","text":"<p>Request (<code>RunRequestV1</code>):</p> <pre><code>{\n  \"text\": \"string (required)\",\n  \"task_goal\": \"string (required)\",\n  \"context_id\": \"api-v1\",\n  \"config\": { \"optional\": \"shallow config overrides\" }\n}\n</code></pre> <p>Response (<code>RunResponseV1</code>):</p> <pre><code>{\n  \"success\": true,\n  \"context_id\": \"api-v1\",\n  \"result\": { \"pipeline_result\": \"...\" }\n}\n</code></pre> <p>On failure:</p> <pre><code>{\n  \"success\": false,\n  \"context_id\": \"api-v1\",\n  \"error\": { \"code\": \"EXECUTION_FAILED\", \"message\": \"\u2026\", \"http_status\": 422 },\n  \"result\": { \"pipeline_result\": \"may be present\" }\n}\n</code></pre>"},{"location":"api/#artifact-behavior","title":"Artifact behavior","text":"<p>The v1 handler snapshots request text into:</p> <ul> <li><code>./artifacts/api/inputs/</code></li> </ul> <p>and writes logs/results under:</p> <ul> <li><code>./artifacts/api/</code></li> </ul> <p>This is deliberate: API runs must still be auditable.</p>"},{"location":"api/#error-semantics","title":"Error semantics","text":"<ul> <li>Schema validation is performed by Pydantic. In FastAPI, invalid requests typically return HTTP 422.</li> <li>Execution failures map to <code>EXECUTION_FAILED</code>.</li> <li>Convergence failures map to <code>CONVERGENCE_FAILED</code>.</li> <li>Unexpected exceptions map to <code>INTERNAL_ERROR</code>.</li> </ul>"},{"location":"api/#openapi-schema","title":"OpenAPI schema","text":"<p>The repository includes an OpenAPI file at <code>api/v1/schema.yaml</code>. Keep the router implementation and schema aligned (avoid \u201cspec drift\u201d).</p>"},{"location":"architecture/ARCHITECTURE/","title":"Architecture","text":"<p>This document is a module-level map of the codebase. It describes where responsibilities live, not every implementation detail.</p>"},{"location":"architecture/ARCHITECTURE/#top-level-components","title":"Top-level components","text":""},{"location":"architecture/ARCHITECTURE/#cli-srcbijux_agentmainpy-srcbijux_agentcli","title":"CLI (<code>src/bijux_agent/main.py</code>, <code>src/bijux_agent/cli/</code>)","text":"<ul> <li>Parses arguments (<code>run</code>, <code>replay</code>)</li> <li>Loads config + environment</li> <li>Invokes the canonical pipeline (<code>AuditableDocPipeline</code>)</li> <li>Writes run artifacts (<code>final_result.json</code>, <code>run_trace.json</code>)</li> </ul>"},{"location":"architecture/ARCHITECTURE/#http-api-srcbijux_agenthttpapi-srcbijux_agentapiv1","title":"HTTP API (<code>src/bijux_agent/httpapi/</code>, <code>src/bijux_agent/api/v1/</code>)","text":"<ul> <li><code>httpapi/v1.py</code> exposes a small FastAPI router (when FastAPI is installed)</li> <li><code>api/v1/*</code> owns request/response schemas and the execution handler</li> <li>The v1 handler is intentionally narrow: it runs the canonical pipeline with a minimal config baseline</li> </ul>"},{"location":"architecture/ARCHITECTURE/#pipeline-core-srcbijux_agentpipeline","title":"Pipeline core (<code>src/bijux_agent/pipeline/</code>)","text":"<ul> <li>Canonical pipeline: <code>pipeline/canonical.py</code> defines <code>AuditableDocPipeline</code></li> <li>Lifecycle semantics: <code>pipeline/control/*</code> defines phases and stop reasons</li> <li>Execution: <code>pipeline/execution/*</code> (agent calls, retries, timeouts)</li> <li>Results: <code>pipeline/results/*</code> defines structured decision/failure artifacts</li> <li>Convergence: <code>pipeline/convergence/*</code> defines convergence detection semantics</li> </ul>"},{"location":"architecture/ARCHITECTURE/#tracing-srcbijux_agenttracing","title":"Tracing (<code>src/bijux_agent/tracing/</code>)","text":"<ul> <li>Trace schema, validation, and upgrades</li> <li>Field classification (deterministic vs observational)</li> <li>Run fingerprinting (pipeline definition + config snapshot hashing)</li> </ul>"},{"location":"architecture/ARCHITECTURE/#models-srcbijux_agentmodels","title":"Models (<code>src/bijux_agent/models/</code>)","text":"<ul> <li>Adapter registry and contracts for LLM backends</li> <li>A strict output contract (<code>AgentOutputSchema</code>) to keep downstream logic stable</li> </ul>"},{"location":"architecture/ARCHITECTURE/#configuration-srcbijux_agentconfig","title":"Configuration (<code>src/bijux_agent/config/</code>)","text":"<ul> <li>Defaults and minimal reference configs</li> <li>Environment key loading/validation (<code>config/env.py</code>)</li> </ul>"},{"location":"architecture/ARCHITECTURE/#data-flow","title":"Data flow","text":"<ol> <li>CLI or API constructs a context (<code>task_goal</code>, input, identifiers).</li> <li><code>AuditableDocPipeline.run(context)</code> orchestrates phases and agent calls.</li> <li>Results are normalized into a final decision, plus trace metadata.</li> <li>The CLI writes:</li> <li><code>result/final_result.json</code> (human-facing summary)</li> <li><code>trace/run_trace.json</code> (audit trail)</li> </ol>"},{"location":"architecture/ARCHITECTURE/#extension-points-and-boundaries","title":"Extension points (and boundaries)","text":"<p>Supported extension points:</p> <ul> <li>adding new agents via the agent registry</li> <li>adding a model adapter (provider) behind the existing contracts</li> </ul> <p>Explicitly not supported (by design):</p> <ul> <li>dynamic pipeline composition at runtime</li> <li>stateful cross-run memory</li> <li>silent retries without a declared policy</li> </ul> <p>See the formal non-goals: <code>docs/spec/refusals.md</code>.</p>"},{"location":"design/determinism/","title":"Determinism (design notes)","text":"<p>Determinism is a design constraint for auditability, not a promise that two LLM runs will always yield byte-identical text.</p>"},{"location":"design/determinism/#what-deterministic-means-here","title":"What \u201cdeterministic\u201d means here","text":"<p>A run is structurally deterministic when:</p> <ul> <li>the pipeline phase order and allowed transitions are fixed,</li> <li>the run configuration is captured and fingerprinted,</li> <li>all trace-critical metadata is recorded,</li> <li>the system can classify replayability honestly.</li> </ul> <p>The system treats LLM sampling as inherently unstable unless explicitly constrained.</p>"},{"location":"design/determinism/#replayability-classification","title":"Replayability classification","text":"<p>The trace header records a <code>replay_status</code>:</p> <ul> <li>REPLAYABLE when <code>model_metadata.temperature == 0.0</code></li> <li>NON_REPLAYABLE otherwise</li> </ul> <p>A trace may still be auditable even when it is non-replayable.</p>"},{"location":"design/determinism/#deterministic-vs-observational-trace-fields","title":"Deterministic vs observational trace fields","text":"<p>Some fields exist for operations and debugging, but cannot be stable across runs (e.g. timestamps). The trace schema classifies fields as:</p> <ul> <li>deterministic: must be stable for replay validation</li> <li>observational: allowed to drift (e.g. <code>start_time</code>, <code>end_time</code>)</li> </ul> <p>Consumers should avoid asserting on observational fields.</p>"},{"location":"design/determinism/#practical-guardrails","title":"Practical guardrails","text":"<p>If you want maximal determinism:</p> <ul> <li>set <code>model_metadata.temperature: 0.0</code></li> <li>avoid time-dependent prompts and external calls</li> <li>treat inputs as immutable snapshots (the CLI already writes a file snapshot for API inputs)</li> <li>do not mutate pipeline phase composition at runtime</li> </ul> <p>For the normative version of these rules, see <code>docs/spec/invariants/determinism.md</code>.</p>"},{"location":"examples/document-review/","title":"Example: document review workflow","text":"<p>This example shows how to use Bijux Agent as an auditable \u201creview runner\u201d over a directory of documents.</p>"},{"location":"examples/document-review/#goal","title":"Goal","text":"<p>Given a folder of files, produce per-file structured results and an overall run verdict you can audit.</p>"},{"location":"examples/document-review/#recommended-setup","title":"Recommended setup","text":"<ol> <li>Put your documents in a single directory (non-recursive processing today).</li> <li>Set a review-oriented task goal in your config, for example:</li> </ol> <pre><code>task_goal: \"review this document for correctness, missing assumptions, and actionable revisions\"\n</code></pre>"},{"location":"examples/document-review/#run","title":"Run","text":"<pre><code>python -m bijux_agent.main run path/to/review_corpus --out artifacts/review_run --config config/config.yml\n</code></pre>"},{"location":"examples/document-review/#how-to-interpret-the-outputs","title":"How to interpret the outputs","text":"<ul> <li><code>artifacts/review_run/result/final_result.json</code> is the first file to read.</li> <li><code>artifacts/review_run/trace/run_trace.json</code> is what you use to validate:</li> <li>which model metadata was used,</li> <li>what the replayability classification is,</li> <li>what fingerprints identify the run inputs and config.</li> </ul>"},{"location":"examples/document-review/#practical-advice","title":"Practical advice","text":"<ul> <li>Keep the task goal narrow. \u201cReview everything\u201d yields unstable scope and weak auditability.</li> <li>Treat the run directory as immutable once produced; regeneration should go to a new <code>--out</code> directory.</li> </ul> <p>See also:</p> <ul> <li><code>docs/user/usage.md</code> (CLI mechanics)</li> <li><code>docs/spec/failure_model.md</code> (how failures are represented)</li> </ul>"},{"location":"examples/minimal-pipeline/","title":"Example: minimal CLI run","text":"<p>This is the fastest way to confirm the CLI, config parsing, and artifact writing are wired correctly.</p>"},{"location":"examples/minimal-pipeline/#1-create-an-input-file","title":"1) Create an input file","text":"<pre><code>mkdir -p examples/tmp\ncat &gt; examples/tmp/input.txt &lt;&lt; 'EOF'\nThis is a small input document.\nEOF\n</code></pre>"},{"location":"examples/minimal-pipeline/#2-run-the-pipeline","title":"2) Run the pipeline","text":"<pre><code>python -m bijux_agent.main run examples/tmp/input.txt --out artifacts/minimal --config config/config.yml\n</code></pre> <p>If processing exactly one file and the run succeeds, the CLI prints the computed JSON result to stdout.</p>"},{"location":"examples/minimal-pipeline/#3-inspect-artifacts","title":"3) Inspect artifacts","text":"<pre><code>ls -R artifacts/minimal\n</code></pre> <p>You should see (paths relative to the run directory):</p> <ul> <li><code>result/final_result.json</code></li> <li><code>trace/run_trace.json</code></li> </ul> <p>For the meaning of these files, see <code>docs/spec/execution_artifacts.md</code>.</p>"},{"location":"legal/security/","title":"Security","text":""},{"location":"legal/security/#reporting-a-vulnerability","title":"Reporting a vulnerability","text":"<p>If you believe you have found a security issue:</p> <ul> <li>Do not open a public GitHub issue with sensitive details.</li> <li>Prefer GitHub Security Advisories (if enabled for the repository) or contact the maintainers privately.</li> </ul> <p>Include:</p> <ul> <li>a clear description of the issue,</li> <li>reproduction steps,</li> <li>affected versions/commits (if known),</li> <li>impact assessment (data exposure, RCE, etc.).</li> </ul>"},{"location":"legal/security/#data-handling-notes","title":"Data handling notes","text":"<ul> <li>The CLI reads local files and may write derived artifacts under the chosen <code>--out</code> run directory.</li> <li>The HTTP API handler snapshots request text to disk under <code>./artifacts/api/inputs/</code> to preserve auditability.</li> <li>Treat <code>artifacts/</code> as sensitive if inputs are sensitive.</li> </ul>"},{"location":"legal/security/#secrets-and-api-keys","title":"Secrets and API keys","text":"<ul> <li>API keys are read from environment variables (optionally via a <code>.env</code> file).</li> <li>Do not commit <code>.env</code> or other secret material to version control.</li> <li>Rotate keys immediately if you suspect exposure.</li> </ul>"},{"location":"legal/security/#third-party-providers","title":"Third-party providers","text":"<p>When configured, the system may send document content to external model providers. You are responsible for ensuring that this is acceptable for your data and threat model.</p>"},{"location":"maintainer/CHANGELOG/","title":"Maintainer changelog","text":"<p>This file tracks maintainer-relevant changes that may not be visible to end users.</p>"},{"location":"maintainer/CHANGELOG/#principles","title":"Principles","text":"<ul> <li>Keep entries short and factual.</li> <li>Prefer linking to PRs/commits when used in the real repository.</li> <li>Record changes that affect:</li> <li>invariants</li> <li>versioning decisions</li> <li>tooling / CI gates</li> <li>trace or taxonomy discipline</li> </ul> <p>(End-user changes belong in the root <code>CHANGELOG.md</code>.)</p>"},{"location":"maintainer/anti-features/","title":"Anti-features (maintainer)","text":"<p>Anti-features are explicit \u201cno\u201d decisions that prevent scope creep.</p> <ul> <li>No stateful cross-run memory by default.</li> <li>No dynamic pipeline graphs at runtime.</li> <li>No silent retries unless driven by an explicit policy.</li> <li>No \u201cmagic\u201d behavior that bypasses trace recording.</li> <li>No claiming replayability when sampling is enabled.</li> </ul> <p>If you want to add an exception, write it down, version it, and update the spec.</p>"},{"location":"maintainer/breaking_refactor/","title":"Breaking refactor policy (maintainer)","text":"<p>\u201cBreaking\u201d means a consumer can no longer safely interpret artifacts or rely on the contract.</p>"},{"location":"maintainer/breaking_refactor/#examples-of-breaking-changes","title":"Examples of breaking changes","text":"<ul> <li>removing or renaming required <code>final_result.json</code> fields</li> <li>changing trace semantics without bumping <code>trace_schema_version</code></li> <li>altering failure taxonomy values (enums) without migration</li> <li>changing replayability classification rules</li> </ul>"},{"location":"maintainer/breaking_refactor/#process","title":"Process","text":"<ol> <li>Declare the break explicitly.</li> <li>Update spec pages.</li> <li>Bump the relevant version(s).</li> <li>Provide an upgrade/migration path when feasible.</li> </ol>"},{"location":"maintainer/code-map/","title":"Code map","text":"<p>High-signal locations:</p> <ul> <li><code>src/bijux_agent/main.py</code> \u2014 CLI entry point</li> <li><code>src/bijux_agent/cli/</code> \u2014 CLI helpers and artifact writing</li> <li><code>src/bijux_agent/httpapi/</code> \u2014 FastAPI integration layer</li> <li><code>src/bijux_agent/api/v1/</code> \u2014 v1 schemas and handlers</li> <li><code>src/bijux_agent/pipeline/</code> \u2014 canonical pipeline, phases, execution, results</li> <li><code>src/bijux_agent/tracing/</code> \u2014 trace schema, validation, upgrades, fingerprints</li> <li><code>tests/</code> \u2014 unit tests and invariants (docs checksums, contract checks)</li> </ul> <p>If you touch <code>docs/spec/*</code>, assume you are changing the contract.</p>"},{"location":"maintainer/docs-parity/","title":"Docs \u2194 code parity","text":"<p>Docs are treated as part of the contract.</p>"},{"location":"maintainer/docs-parity/#what-parity-means","title":"What \u201cparity\u201d means","text":"<ul> <li>The spec must not describe behavior the code does not implement.</li> <li>The code must not implement behavior the spec forbids or fails to mention (when contract-relevant).</li> <li>Where drift is unavoidable (e.g. planned endpoints), drift must be called out explicitly.</li> </ul>"},{"location":"maintainer/docs-parity/#practical-rule","title":"Practical rule","text":"<p>If you change runtime behavior or artifact structure:</p> <ol> <li>Update the relevant <code>docs/spec/*</code> page.</li> <li>Regenerate documentation checksums (<code>docs/doc_checksums.json</code>).</li> <li>Keep <code>docs/index.md</code> file list in sync.</li> </ol> <p>See: <code>docs/maintainer/documentation-invariant.md</code>.</p>"},{"location":"maintainer/docs_contract/","title":"Documentation contract (maintainer)","text":"<p>The documentation set must remain:</p> <ul> <li>auditable: changes are explicit and checksum-tracked</li> <li>tiered: user vs overview vs spec vs maintainer</li> <li>accurate: contract pages match runtime behavior</li> </ul>"},{"location":"maintainer/docs_contract/#required-properties","title":"Required properties","text":"<ul> <li>Every markdown file under <code>docs/</code> is tracked by checksum.</li> <li><code>docs/index.md</code> lists every tracked file.</li> <li>Spec pages use normative language and avoid implementation noise.</li> </ul>"},{"location":"maintainer/docs_contract/#what-to-avoid","title":"What to avoid","text":"<ul> <li>Duplicating the same concept across multiple pages without cross-links.</li> <li>Encoding unstable implementation details as guarantees.</li> <li>Mixing maintainer process notes into the spec.</li> </ul> <p>Enforcement: <code>tests/invariants/test_documentation_invariant.py</code>.</p>"},{"location":"maintainer/docs_voice/","title":"Documentation voice (maintainer)","text":"<p>Write like a senior engineer speaking to another senior engineer:</p> <ul> <li>lead with the thing the reader is trying to do,</li> <li>state requirements vs recommendations clearly,</li> <li>prefer concrete examples over slogans,</li> <li>keep the spec narrow and test-backed,</li> <li>avoid hand-wavy language (\u201cprobably\u201d, \u201cusually\u201d) in contract pages.</li> </ul>"},{"location":"maintainer/docstring-policy/","title":"Docstring policy (maintainer)","text":"<p>Docstrings are not a dumping ground for design documents. They exist to make code easier to use and harder to misuse.</p>"},{"location":"maintainer/docstring-policy/#required","title":"Required","text":"<ul> <li>Public functions/classes MUST have docstrings describing purpose and key constraints.</li> <li>Contract-relevant types (trace schema, failure artifacts) SHOULD have docstrings that match the spec vocabulary.</li> </ul>"},{"location":"maintainer/docstring-policy/#avoid","title":"Avoid","text":"<ul> <li>Repeating spec text verbatim.</li> <li>Describing behavior that tests do not enforce.</li> <li>Encoding large examples in docstrings (prefer docs pages for that).</li> </ul> <p>If a docstring becomes the \u201csource of truth\u201d, the docs are already drifting.</p>"},{"location":"maintainer/documentation-invariant/","title":"Documentation invariant (maintainer)","text":"<p>Documentation is checksum-tracked and test-enforced.</p>"},{"location":"maintainer/documentation-invariant/#invariant","title":"Invariant","text":"<ol> <li>Every <code>docs/**/*.md</code> file MUST appear in <code>docs/doc_checksums.json</code>.</li> <li>Every tracked file MUST be listed in <code>docs/index.md</code> as a <code>- docs/...</code> bullet.</li> <li>Each tracked file\u2019s SHA-256 MUST match the value in <code>docs/doc_checksums.json</code>.</li> </ol>"},{"location":"maintainer/documentation-invariant/#workflow-when-editing-docs","title":"Workflow when editing docs","text":"<ol> <li>Edit docs.</li> <li>Regenerate <code>docs/doc_checksums.json</code> (SHA-256 per file).</li> <li>Ensure <code>docs/index.md</code> lists all tracked files.</li> </ol> <p>The test enforcing this lives at <code>tests/invariants/test_documentation_invariant.py</code>.</p>"},{"location":"maintainer/evaluation/","title":"Evaluation (maintainer)","text":"<p>You cannot evaluate an LLM system purely by \u201cdoes it look good\u201d. You need a regression story.</p>"},{"location":"maintainer/evaluation/#what-to-evaluate","title":"What to evaluate","text":"<ul> <li>Artifact integrity: does the run produce valid <code>final_result.json</code> and <code>run_trace.json</code>?</li> <li>Contract compliance: are required fields present and correctly classified?</li> <li>Failure taxonomy: do failures map cleanly into <code>FailureArtifact</code> profiles?</li> <li>Replay validation: can traces be validated/upgraded under the current schema?</li> </ul>"},{"location":"maintainer/evaluation/#what-not-to-evaluate-here","title":"What not to evaluate here","text":"<ul> <li>model quality claims (domain-dependent)</li> <li>benchmark scores without trace-backed provenance</li> </ul>"},{"location":"maintainer/evaluation/#practical-regression-loop","title":"Practical regression loop","text":"<ul> <li>Create small deterministic fixtures (text files).</li> <li>Run the CLI and compare:</li> <li>run fingerprints,</li> <li>replayability classification,</li> <li>presence/shape of key fields.</li> </ul>"},{"location":"maintainer/first-refactor-plan/","title":"First refactor plan (maintainer)","text":"<p>A pragmatic first refactor should reduce risk, not expand scope.</p>"},{"location":"maintainer/first-refactor-plan/#proposed-first-steps","title":"Proposed first steps","text":"<ol> <li>Lock trace schema discipline</li> <li>ensure every run writes a valid trace (normal run)</li> <li> <p>validate/upgrade trace payloads consistently</p> </li> <li> <p>Align CLI and API</p> </li> <li>same minimal artifact semantics for equivalent inputs/config</li> <li> <p>consistent error mapping and termination reasons</p> </li> <li> <p>Simplify configuration</p> </li> <li>make \u201cwhat config keys matter\u201d obvious</li> <li> <p>keep defaults in one place</p> </li> <li> <p>Strengthen tests</p> </li> <li>add small fixtures that validate trace headers and failure taxonomy</li> </ol> <p>If you cannot explain the refactor in one page, it\u2019s probably too big.</p>"},{"location":"maintainer/pipeline_refactor_rules/","title":"Pipeline refactor rules (maintainer)","text":"<p>These rules exist to prevent \u201crefactor\u201d from becoming \u201cbehavior drift\u201d.</p>"},{"location":"maintainer/pipeline_refactor_rules/#rules","title":"Rules","text":"<ul> <li>Do not change canonical phase order casually.</li> <li>Any change to allowed transitions requires:</li> <li>explicit rationale,</li> <li>updated spec text,</li> <li>versioning decision.</li> <li>Preserve trace writing semantics; do not introduce execution paths that bypass trace recording.</li> <li>When adding new trace fields, keep them forward-compatible (consumers ignore unknown fields).</li> </ul>"},{"location":"maintainer/pipeline_refactor_rules/#minimal-acceptance-criteria","title":"Minimal acceptance criteria","text":"<ul> <li>unit tests pass</li> <li>documentation invariant tests pass</li> <li>trace validation succeeds for a normal run</li> </ul>"},{"location":"maintainer/project_tree/","title":"Project tree","text":"<p>High-signal directories:</p> <ul> <li><code>src/bijux_agent/</code> \u2014 library and runtime code</li> <li><code>tests/</code> \u2014 unit + invariant tests</li> <li><code>docs/</code> \u2014 MkDocs sources (this directory)</li> <li><code>config/</code> \u2014 runtime configuration examples</li> <li><code>api/</code> \u2014 OpenAPI schema and API assets</li> <li><code>makefiles/</code> \u2014 Make targets used by CI and developers</li> </ul> <p>Generated artifacts belong under <code>artifacts/</code> (or under the CLI <code>--out</code> directory).</p>"},{"location":"maintainer/refactor-invariants/","title":"Refactor invariants (maintainer)","text":"<p>Refactors are allowed to change structure, but not the contract.</p>"},{"location":"maintainer/refactor-invariants/#must-stay-true","title":"Must stay true","text":"<ul> <li>trace schema versioning remains meaningful (no silent breaking changes)</li> <li>failure taxonomy remains total (profiles cover all classes)</li> <li>canonical pipeline definition remains stable unless explicitly versioned</li> <li>docs checksum invariant continues to pass</li> </ul>"},{"location":"maintainer/refactor-invariants/#if-you-must-break-something","title":"If you must break something","text":"<ul> <li>state the break explicitly</li> <li>bump the relevant version (trace schema and/or contract)</li> <li>update spec pages and checksums</li> </ul>"},{"location":"maintainer/refactor-plan/","title":"Refactor plan (maintainer)","text":"<p>This is a living plan; it should stay short and honest.</p>"},{"location":"maintainer/refactor-plan/#near-term","title":"Near-term","text":"<ul> <li>converge on a single LLM adapter interface</li> <li>ensure CLI and API produce equivalent artifacts for equivalent inputs/config</li> </ul>"},{"location":"maintainer/refactor-plan/#medium-term","title":"Medium-term","text":"<ul> <li>emit per-phase trace entries (not only finalize)</li> <li>strengthen trace upgrade tooling and validation UX</li> </ul>"},{"location":"maintainer/refactor-plan/#guardrails","title":"Guardrails","text":"<ul> <li>preserve <code>docs/spec/*</code> invariants unless you version a breaking change</li> <li>preserve failure taxonomy and trace schema discipline</li> </ul>"},{"location":"maintainer/refactor-priority/","title":"Refactor priority (maintainer)","text":"<p>This is an opinionated priority list for improving correctness and maintainability.</p> <ol> <li>Artifact correctness first: trace validity, taxonomy correctness, schema discipline.</li> <li>Single adapter interface: reduce backend complexity behind one contract.</li> <li>Trace richness: phase-level entries and better diagnostics.</li> <li>Ergonomics: CLI/API parity, clearer configuration surface.</li> <li>Performance: only after correctness is boring.</li> </ol> <p>Avoid polishing UX while the contract is still moving.</p>"},{"location":"maintainer/refactor_scope/","title":"Refactor scope (maintainer)","text":""},{"location":"maintainer/refactor_scope/#in-scope","title":"In scope","text":"<ul> <li>internal module restructuring</li> <li>improved tracing and replay tooling</li> <li>configuration cleanup (without breaking the contract)</li> <li>tests that tighten invariants</li> </ul>"},{"location":"maintainer/refactor_scope/#out-of-scope-without-explicit-design-work","title":"Out of scope (without explicit design work)","text":"<ul> <li>new product features unrelated to auditability</li> <li>stateful cross-run storage</li> <li>dynamic user-defined pipeline graphs</li> </ul> <p>If you want to expand scope, start with a design note and update the spec.</p>"},{"location":"maintainer/rejected-designs/","title":"Rejected designs (maintainer)","text":"<p>This is a lightweight record of decisions we did not take, so we don\u2019t re-litigate them every few months.</p>"},{"location":"maintainer/rejected-designs/#1-fully-dynamic-pipeline-graphs","title":"1) Fully dynamic pipeline graphs","text":"<p>Rejected because it weakens auditability and makes traces less comparable across runs.</p>"},{"location":"maintainer/rejected-designs/#2-implicit-cross-run-memory","title":"2) Implicit cross-run memory","text":"<p>Rejected because it introduces hidden state and makes replay validation meaningless without external state capture.</p>"},{"location":"maintainer/rejected-designs/#3-best-effort-trace-metadata","title":"3) \u201cBest effort\u201d trace metadata","text":"<p>Rejected because partial traces invite overconfident consumers. The system should fail fast rather than emit unverifiable artifacts.</p>"},{"location":"maintainer/spec/","title":"Maintainer index","text":"<p>This section is for people changing the codebase and trying to keep the contract intact.</p> <p>If you are a user of the CLI/API, you probably want <code>docs/user/usage.md</code> instead.</p>"},{"location":"maintainer/spec/#non-negotiables","title":"Non-negotiables","text":"<ul> <li>Preserve the spec (<code>docs/spec/*</code>) unless you intentionally version a breaking change.</li> <li>Preserve the documentation checksum invariant (<code>docs/doc_checksums.json</code> + <code>docs/index.md</code> list).</li> <li>Do not add hidden behavior (silent retries, implicit state, non-auditable side effects).</li> </ul>"},{"location":"maintainer/spec/#start-here","title":"Start here","text":"<ol> <li><code>docs/maintainer/tooling.md</code></li> <li><code>docs/maintainer/testing.md</code></li> <li><code>docs/maintainer/code-map.md</code></li> <li><code>docs/maintainer/documentation-invariant.md</code></li> </ol>"},{"location":"maintainer/system-boundaries/","title":"System boundaries (maintainer)","text":"<p>Bijux Agent is a pipeline runner with strict audit artifacts. Keeping the boundary sharp is how the project stays maintainable.</p>"},{"location":"maintainer/system-boundaries/#inside-the-boundary","title":"Inside the boundary","text":"<ul> <li>construct a context</li> <li>run the canonical pipeline</li> <li>record trace and final artifacts</li> <li>expose a minimal API surface</li> </ul>"},{"location":"maintainer/system-boundaries/#outside-the-boundary","title":"Outside the boundary","text":"<ul> <li>long-lived storage and user accounts</li> <li>permission systems and multi-tenant isolation</li> <li>UI and product workflows</li> <li>domain-specific \u201ccorrectness\u201d definitions</li> </ul> <p>If a feature drags the project toward \u201capplication platform\u201d, resist it unless it directly strengthens auditability.</p>"},{"location":"maintainer/testing/","title":"Testing (maintainer)","text":"<p>The test suite exists to prevent contract drift.</p>"},{"location":"maintainer/testing/#what-tests-must-cover","title":"What tests must cover","text":"<ul> <li>documentation checksum invariant</li> <li>trace schema validation and upgrade paths</li> <li>failure taxonomy completeness and validation</li> <li>CLI/API surfaces producing coherent artifacts</li> </ul>"},{"location":"maintainer/testing/#running-tests","title":"Running tests","text":"<pre><code>make test\n</code></pre> <p>If you are iterating quickly:</p> <pre><code>pytest -q\n</code></pre>"},{"location":"maintainer/testing/#invariant-tests","title":"Invariant tests","text":"<p>Invariant tests are allowed to be strict. If an invariant test fails, do not \u201cfix\u201d it by weakening the invariant without updating the spec and versioning appropriately.</p>"},{"location":"maintainer/tooling/","title":"Tooling (maintainer)","text":"<p>This repository is intentionally Make-driven so contributors get reproducible commands.</p>"},{"location":"maintainer/tooling/#bootstrap","title":"Bootstrap","text":"<pre><code>make bootstrap\n</code></pre> <p>Creates <code>.venv</code>, installs dependencies, and installs git hooks (when configured).</p>"},{"location":"maintainer/tooling/#common-targets","title":"Common targets","text":"<pre><code>make test\nmake lint\nmake docs\nmake api\nmake quality\nmake security\n</code></pre> <p>List everything:</p> <pre><code>make help\n</code></pre>"},{"location":"maintainer/tooling/#notes","title":"Notes","text":"<ul> <li>CI should use the same Make targets as local development.</li> <li>If you add a new tool, expose it via a Make target (don\u2019t hide it in CI YAML only).</li> </ul>"},{"location":"maintainer/typing-status/","title":"Typing status (maintainer)","text":"<p>Typing is treated as a correctness tool, not as decoration.</p>"},{"location":"maintainer/typing-status/#policy","title":"Policy","text":"<ul> <li>New modules should be typed.</li> <li>Contract-relevant modules (trace schema, failure artifacts, API schemas) SHOULD be fully typed.</li> <li>Avoid \u201ctype: ignore\u201d unless you can explain why it is safe.</li> </ul>"},{"location":"maintainer/typing-status/#practical-expectation","title":"Practical expectation","text":"<p>If mypy coverage is incomplete, focus typing effort where it reduces runtime ambiguity:</p> <ul> <li>schemas and validation</li> <li>artifact writing</li> <li>boundary layers (CLI/API)</li> </ul>"},{"location":"maintainer/undefined-behavior/","title":"Undefined behavior (maintainer)","text":"<p>Undefined behavior is where bugs hide. This page lists areas that are intentionally not promised.</p>"},{"location":"maintainer/undefined-behavior/#examples","title":"Examples","text":"<ul> <li>model output quality or completeness</li> <li>provider stability and tokenization drift</li> <li>performance and throughput</li> <li>cross-run caching semantics (unless explicitly specified)</li> </ul>"},{"location":"maintainer/undefined-behavior/#rule","title":"Rule","text":"<p>If a behavior matters to integrators, it must move from \u201cundefined\u201d to \u201cspecified\u201d: write it in <code>docs/spec/*</code>, add tests where feasible, and version it.</p>"},{"location":"maintainer/vocabulary/","title":"Maintainer vocabulary","text":"<p>This is a pragmatic glossary for maintainers. The normative vocabulary lives in <code>docs/spec/vocabulary.md</code>.</p> <ul> <li>Contract drift: code and spec disagree.</li> <li>Artifact drift: output JSON changes without versioning.</li> <li>Spec drift: docs/spec claims behavior not implemented.</li> <li>Replay validation: checking a trace satisfies the contract (not rerunning models).</li> <li>Canonicalization: stable JSON serialization used for hashing/fingerprints.</li> </ul>"},{"location":"maintainer/shared/glossary/","title":"Maintainer glossary","text":"<ul> <li>Invariant: a property enforced by tests and/or required by the spec.</li> <li>Contract: the set of behaviors and artifacts consumers rely on.</li> <li>Upgrade path: logic that allows older trace payloads to be interpreted under newer schemas.</li> <li>Schema discipline: no silent breaking changes; versions gate compatibility.</li> </ul>"},{"location":"maintainer/shared/structure/","title":"Docs structure (maintainer)","text":"<p>Every page should answer:</p> <ol> <li>What is this for?</li> <li>Who is it for?</li> <li>What can the reader do with it?</li> </ol>"},{"location":"maintainer/shared/structure/#recommended-page-skeleton","title":"Recommended page skeleton","text":"<ul> <li>Title</li> <li>1\u20132 sentence summary</li> <li>Sections with actionable headings</li> <li>Links to next relevant pages</li> </ul> <p>For spec pages, prefer: scope \u2192 guarantees \u2192 non-guarantees \u2192 edge cases.</p>"},{"location":"maintainer/shared/style/","title":"Docs style (maintainer)","text":""},{"location":"maintainer/shared/style/#formatting","title":"Formatting","text":"<ul> <li>Use short paragraphs and bullets.</li> <li>Prefer tables for enums, matrices, and contracts.</li> <li>Avoid long prose where a checklist works.</li> </ul>"},{"location":"maintainer/shared/style/#linking","title":"Linking","text":"<ul> <li>Prefer relative links inside <code>docs/</code>.</li> <li>When referencing code, include a path (e.g. <code>src/bijux_agent/tracing/trace.py</code>).</li> </ul>"},{"location":"maintainer/shared/style/#code-blocks","title":"Code blocks","text":"<ul> <li>Use fenced code blocks with a language tag (<code>bash</code>, <code>json</code>, <code>yaml</code>, <code>python</code>).</li> <li>Keep snippets minimal and correct.</li> </ul>"},{"location":"overview/concepts/","title":"Concepts","text":"<p>This project exists to make LLM-backed document processing auditable. The core design choice is that a run must leave behind artifacts that can be inspected, diffed, and validated.</p>"},{"location":"overview/concepts/#pipeline-as-a-contract","title":"Pipeline as a contract","text":"<p>A run is an execution of the canonical pipeline (<code>AuditableDocPipeline</code>) over a context:</p> <ul> <li>a goal (<code>task_goal</code>)</li> <li>an input (<code>text</code> or a <code>file_path</code>)</li> <li>a stable identifier (<code>context_id</code>)</li> </ul> <p>The pipeline is canonical: its phase order and allowed transitions are fixed and versioned. Consumers should assume \u201csame inputs + same config + same model settings\u201d implies \u201csame trace classification\u201d, not \u201csame model output\u201d.</p>"},{"location":"overview/concepts/#phases","title":"Phases","text":"<p>The canonical lifecycle is:</p> <p><code>INIT \u2192 PLAN \u2192 EXECUTE \u2192 JUDGE \u2192 VERIFY \u2192 FINALIZE \u2192 DONE</code></p> <p>Not every phase necessarily produces user-visible content today, but the lifecycle exists so traces have a stable semantic scaffold.</p>"},{"location":"overview/concepts/#artifacts-and-why-they-matter","title":"Artifacts and why they matter","text":"<p>A normal CLI run writes two primary artifacts:</p> <ul> <li><code>result/final_result.json</code> \u2014 a compact verdict summary (what you would read first)</li> <li><code>trace/run_trace.json</code> \u2014 the trace (what you audit and validate)</li> </ul> <p>The trace is designed to support:</p> <ul> <li>post-hoc debugging (\u201cwhy did we decide PASS?\u201d),</li> <li>regression detection (compare fingerprints across versions),</li> <li>replay validation (\u201cdoes this trace satisfy the contract?\u201d).</li> </ul>"},{"location":"overview/concepts/#determinism-vs-replayability","title":"Determinism vs replayability","text":"<p>Determinism is treated as a classification, not a promise that LLM sampling will match across time.</p> <p>The system marks traces:</p> <ul> <li>REPLAYABLE when <code>model_metadata.temperature == 0.0</code></li> <li>NON_REPLAYABLE otherwise</li> </ul> <p>Replayability controls what the tooling is allowed to claim, not what the user is allowed to do.</p>"},{"location":"overview/concepts/#failure-semantics-high-level","title":"Failure semantics (high-level)","text":"<p>Failures are represented by an immutable <code>FailureArtifact</code>:</p> <ul> <li>a machine-actionable class (<code>failure_class</code>)</li> <li>an operational/epistemic category</li> <li>recoverability (whether the orchestrator may attempt recovery)</li> </ul> <p>See the formal taxonomy: <code>docs/spec/failure_model.md</code>.</p>"},{"location":"overview/concepts/#where-to-go-next","title":"Where to go next","text":"<ul> <li>For hands-on usage: <code>docs/user/usage.md</code></li> <li>For the formal contract: <code>docs/spec/read_this_first.md</code></li> </ul>"},{"location":"overview/readme/","title":"Documentation orientation","text":"<p>The docs are organized by audience:</p> <ul> <li>User: installation, CLI, output artifacts.</li> <li>Overview: mental model and vocabulary (explanatory).</li> <li>Reference (Spec): test-backed runtime contract (normative).</li> <li>Maintainer: repo hygiene, refactor guardrails, contributor workflow.</li> </ul>"},{"location":"overview/readme/#normative-language","title":"Normative language","text":"<p>In the Spec, the words MUST, SHOULD, and MAY are used in the RFC sense:</p> <ul> <li>MUST: required for correctness and for contract/invariant tests</li> <li>SHOULD: strong recommendation; deviating requires an explicit reason</li> <li>MAY: optional behavior</li> </ul> <p>Outside the spec, text is explanatory: it aims to help you use the system, not to bind it.</p>"},{"location":"spec/architecture_diagram/","title":"Architecture diagram (spec)","text":"<p>This diagram is a conceptual view of the runtime contract.</p> <pre><code>Caller (CLI / HTTP)\n        |\n        v\n+------------------------+\n| AuditableDocPipeline   |\n|  (canonical phases)    |\n+------------------------+\n   |        |        |\n   v        v        v\n Agents   Decision  Failure model\n   |        |        |\n   +--------+--------+\n            |\n            v\n     +--------------+\n     | Trace writer |\n     | (run_trace)  |\n     +--------------+\n            |\n            v\n     +--------------+\n     | final_result |\n     +--------------+\n</code></pre> <p>For the concrete module map, see <code>docs/architecture/ARCHITECTURE.md</code>.</p>"},{"location":"spec/execution_artifacts/","title":"Execution artifacts (spec)","text":""},{"location":"spec/execution_artifacts/#artifact-set","title":"Artifact set","text":"<p>A normal CLI run writes these primary artifacts under <code>--out &lt;RUN_DIR&gt;</code>:</p> <ul> <li><code>result/final_result.json</code></li> <li><code>trace/run_trace.json</code></li> </ul> <p>Additional logs may be written to the directory configured in <code>logging.log_dir</code>.</p>"},{"location":"spec/execution_artifacts/#final_resultjson-verdict-summary","title":"<code>final_result.json</code> (verdict summary)","text":"<p>This artifact is the first thing a human should read.</p> <p>It MUST include:</p> <ul> <li><code>verdict</code> (string; decision outcome)</li> <li><code>confidence</code> (float)</li> <li><code>epistemic_status</code> (string)</li> <li><code>runtime_version</code> (string)</li> <li><code>termination_reason</code> (string)</li> </ul> <p>It SHOULD include:</p> <ul> <li><code>trace_path</code> (relative path to <code>run_trace.json</code> when a trace exists)</li> <li>convergence fields (<code>converged</code>, <code>convergence_reason</code>, <code>convergence_iterations</code>)</li> <li><code>model_metadata</code> (when available)</li> </ul>"},{"location":"spec/execution_artifacts/#run_tracejson-audit-trace","title":"<code>run_trace.json</code> (audit trace)","text":"<p>A trace MUST include:</p> <ul> <li>a header with <code>trace_schema_version</code></li> <li><code>runtime_version</code></li> <li><code>model_metadata</code></li> <li>at least one trace entry</li> </ul> <p>Trace entries MAY include:</p> <ul> <li><code>replay_metadata</code> and run fingerprints (to identify inputs/config/pipeline)</li> <li>structured failure and decision artifacts</li> <li>observational timing fields (timestamps)</li> </ul>"},{"location":"spec/execution_artifacts/#forward-compatibility","title":"Forward compatibility","text":"<ul> <li>Producers MAY add new fields.</li> <li>Consumers MUST ignore unknown fields.</li> <li>Breaking changes MUST bump the trace schema version.</li> </ul> <p>See also:</p> <ul> <li><code>docs/spec/identity.md</code> (versioning and identity)</li> <li><code>docs/spec/invariants/determinism.md</code> (deterministic vs observational fields)</li> </ul>"},{"location":"spec/execution_contracts/","title":"Execution contracts (spec)","text":""},{"location":"spec/execution_contracts/#input-contract-context","title":"Input contract (context)","text":"<p>A pipeline run consumes a mapping called the context.</p> <p>Required keys:</p> <ul> <li><code>task_goal</code> (string)</li> </ul> <p>Optional keys:</p> <ul> <li><code>context_id</code> (string)</li> <li><code>text</code> (string) \u2014 inline input</li> <li><code>file_path</code> (string) \u2014 path to a file containing the input</li> </ul> <p>Constraints:</p> <ul> <li>At least one of <code>text</code> or <code>file_path</code> MUST be provided.</li> <li>Additional keys MAY be present to support domain-specific workflows.</li> </ul>"},{"location":"spec/execution_contracts/#cli-mapping","title":"CLI mapping","text":"<p>The CLI constructs context from:</p> <ul> <li><code>task_goal</code> from YAML config (<code>task_goal</code>, or a built-in default)</li> <li><code>file_path</code> from the input path (file) or each file in the input directory</li> <li><code>context_id</code> derived from the file stem</li> </ul>"},{"location":"spec/execution_contracts/#api-v1-mapping","title":"API v1 mapping","text":"<p>The API v1 handler constructs context from:</p> <ul> <li><code>text</code> and <code>task_goal</code> in the request</li> <li><code>context_id</code> (default <code>api-v1</code>)</li> <li>a deterministic on-disk snapshot path written under <code>./artifacts/api/inputs/</code></li> </ul>"},{"location":"spec/execution_contracts/#output-contract","title":"Output contract","text":"<p>The pipeline returns a mapping with (at minimum):</p> <ul> <li><code>stages</code>: <code>{stage_name: stage_output}</code></li> <li><code>final_status</code>: a summary object</li> </ul> <p><code>final_status</code> MUST include:</p> <ul> <li><code>success</code> (bool)</li> <li><code>termination_reason</code></li> <li><code>stages_processed</code> (list of strings)</li> <li><code>iterations</code> (int)</li> </ul>"},{"location":"spec/execution_contracts/#dry-run-semantics","title":"Dry-run semantics","text":"<ul> <li>Dry-run MUST NOT claim model-derived outputs.</li> <li>Dry-run MUST still produce a coherent <code>final_result.json</code> suitable for wiring checks.</li> </ul>"},{"location":"spec/execution_guarantees/","title":"Execution guarantees (spec)","text":"<p>This document describes what a caller can rely on after invoking a run.</p>"},{"location":"spec/execution_guarantees/#cli-guarantees-normal-run","title":"CLI guarantees (normal run)","text":"<p>For <code>python -m bijux_agent.main run \u2026</code> without <code>--dry-run</code>:</p> <ul> <li>The CLI MUST create a run directory at <code>--out</code>.</li> <li>The CLI MUST write <code>result/final_result.json</code>.</li> <li>The CLI MUST write <code>trace/run_trace.json</code>.</li> <li>The trace MUST validate (or be upgradeable) under the local trace schema.</li> </ul>"},{"location":"spec/execution_guarantees/#cli-guarantees-dry-run","title":"CLI guarantees (dry-run)","text":"<p>For <code>run --dry-run</code>:</p> <ul> <li>The CLI MUST validate input discovery and configuration loading.</li> <li>The CLI MUST write <code>result/final_result.json</code>.</li> <li>The CLI MUST NOT claim model-computed content.</li> <li>The CLI MAY skip producing a trace.</li> </ul>"},{"location":"spec/execution_guarantees/#api-guarantees-v1","title":"API guarantees (v1)","text":"<p>For <code>POST /v1/run</code>:</p> <ul> <li>The handler MUST validate the request payload with the v1 schema.</li> <li>The handler MUST return a structured response with <code>success</code> and <code>context_id</code>.</li> <li>On failure, the handler MUST return a structured <code>error</code> object.</li> </ul>"},{"location":"spec/execution_guarantees/#non-guarantees","title":"Non-guarantees","text":"<ul> <li>No guarantee that outputs are \u201ccorrect\u201d or \u201ccomplete\u201d.</li> <li>No guarantee of identical outputs across time, even under temperature 0 (providers can change).</li> <li>No guarantee of stable performance, throughput, or token usage.</li> </ul>"},{"location":"spec/execution_intent_matrix/","title":"Execution intent matrix (spec)","text":"<p>This matrix clarifies which artifacts are expected for each execution intent.</p> Intent Surface Pipeline executed <code>final_result.json</code> <code>run_trace.json</code> Normal run <code>main run</code> Yes Yes Yes Dry-run <code>main run --dry-run</code> No (simulated) Yes Optional Replay <code>main replay</code> No No Input only <p>Notes:</p> <ul> <li>Dry-run exists for wiring checks and file discovery validation.</li> <li>Replay validates recorded outcomes; it is not a model re-execution mechanism.</li> </ul>"},{"location":"spec/execution_lifecycle/","title":"Execution lifecycle (spec)","text":"<p>The canonical pipeline lifecycle exists to make traces semantically stable across refactors.</p>"},{"location":"spec/execution_lifecycle/#canonical-phases","title":"Canonical phases","text":"Phase Purpose Allowed transitions <code>INIT</code> Pre-run validation and context normalization <code>PLAN</code> <code>PLAN</code> Planning / decomposition (if enabled) <code>EXECUTE</code> <code>EXECUTE</code> Main agent execution <code>JUDGE</code> <code>JUDGE</code> Convert agent outputs into a decision <code>VERIFY</code> <code>VERIFY</code> Optional verification / veto checks <code>FINALIZE</code> <code>FINALIZE</code> Emit final artifacts and trace metadata <code>DONE</code> <code>DONE</code> Terminal (none) <code>ABORTED</code> Terminal for fatal aborts (none) <p>Allowed transitions are defined in code by the canonical pipeline definition.</p>"},{"location":"spec/execution_lifecycle/#stop-reasons-and-termination","title":"Stop reasons and termination","text":"<p>The system records:</p> <ul> <li>stop reasons (why a phase stopped), and</li> <li>termination reasons (why the overall run ended)</li> </ul> <p>Termination reasons are part of <code>final_status</code> and are also recorded in trace entries when present.</p>"},{"location":"spec/execution_lifecycle/#trace-expectations","title":"Trace expectations","text":"<ul> <li>A trace MUST contain at least one entry.</li> <li>Entries SHOULD be tagged with the phase they correspond to when available.</li> </ul> <p>See also:</p> <ul> <li><code>docs/spec/execution_artifacts.md</code></li> <li><code>docs/spec/failure_semantics.md</code></li> </ul>"},{"location":"spec/failure_model/","title":"Failure model (spec)","text":"<p>Failures are represented as immutable <code>FailureArtifact</code> objects.</p>"},{"location":"spec/failure_model/#failureartifact-fields","title":"<code>FailureArtifact</code> fields","text":"<p>A failure artifact MUST include:</p> <ul> <li><code>failure_class</code> \u2014 machine-actionable classification</li> <li><code>category</code> \u2014 <code>operational_failure</code> or <code>epistemic_failure</code></li> <li><code>phase</code> \u2014 canonical phase where the failure occurred</li> <li><code>recoverable</code> \u2014 whether the runner may attempt recovery</li> <li><code>mode</code> and <code>message</code> \u2014 how the failure was detected and what happened</li> </ul>"},{"location":"spec/failure_model/#failure-classes-and-profiles","title":"Failure classes and profiles","text":"<p>Each <code>FailureClass</code> has a profile defining retryability, replayability, and category. The profile is the source of truth for how the runner and tooling may react.</p> FailureClass Category Retryable Replayable <code>validation_error</code> operational No Yes <code>execution_error</code> operational Yes No <code>resource_exhaustion</code> operational Yes No <code>fatal_failure</code> operational No No <code>user_interruption</code> operational No Yes <code>budget_exceeded</code> operational No Yes <code>max_iterations</code> operational No Yes <code>verification_veto</code> operational No Yes <code>epistemic_uncertainty</code> epistemic No Yes"},{"location":"spec/failure_model/#invariants","title":"Invariants","text":"<ul> <li>Every <code>FailureClass</code> MUST have a profile.</li> <li>A failure artifact\u2019s <code>category</code> MUST match the profile\u2019s category.</li> <li>If <code>recoverable</code> is true, the profile MUST mark the class retryable.</li> </ul> <p>(Implementation reference: <code>src/bijux_agent/pipeline/results/failure.py</code>.)</p>"},{"location":"spec/failure_semantics/","title":"Failure semantics (spec)","text":"<p>This document explains how failures propagate through the pipeline and into artifacts.</p>"},{"location":"spec/failure_semantics/#where-failures-appear","title":"Where failures appear","text":"<p>Failures can surface in:</p> <ul> <li>the pipeline result (<code>final_status</code>)</li> <li>trace entries (<code>failure_artifact</code>)</li> <li>API responses (<code>error</code> object)</li> </ul> <p>The representation is intentionally redundant: the verdict summary is for humans, the trace is for auditing and tooling.</p>"},{"location":"spec/failure_semantics/#recoverable-vs-non-recoverable","title":"Recoverable vs non-recoverable","text":"<p>A failure artifact includes <code>recoverable</code>:</p> <ul> <li><code>recoverable: true</code> means the orchestrator MAY attempt a recovery strategy (e.g. retry)</li> <li><code>recoverable: false</code> means the run MUST terminate (or move to a non-retry fallback path)</li> </ul> <p>Recoverability is constrained by the failure class profile; see <code>docs/spec/failure_model.md</code>.</p>"},{"location":"spec/failure_semantics/#operational-vs-epistemic-failures","title":"Operational vs epistemic failures","text":"<ul> <li>Operational failures: timeouts, resource exhaustion, validation errors, etc.</li> <li>Epistemic failures: the system cannot justify a confident decision (e.g. insufficient evidence)</li> </ul> <p>Epistemic failures are not \u201cbugs\u201d; they are explicit outcomes that preserve honesty.</p>"},{"location":"spec/failure_semantics/#trace-replayability-interaction","title":"Trace replayability interaction","text":"<p>Some failures are replayable (safe to validate deterministically), others are not. If a failure is non-replayable, replay tooling MUST not claim deterministic reproducibility.</p>"},{"location":"spec/failure_semantics/#contractual-rule","title":"Contractual rule","text":"<p>If a failure artifact violates taxonomy or profiles, the system MUST fail fast rather than emit an invalid trace.</p>"},{"location":"spec/identity/","title":"Identity and versioning (spec)","text":"<p>A trace is only useful if a consumer can identify what produced it.</p>"},{"location":"spec/identity/#required-identifiers","title":"Required identifiers","text":"<p>Traces and/or artifacts MUST record:</p> <ul> <li><code>trace_schema_version</code> \u2014 compatibility gate for <code>run_trace.json</code></li> <li><code>runtime_version</code> \u2014 the package/runtime version producing the artifact</li> <li><code>model_metadata</code> \u2014 provider, model name, temperature, max tokens</li> </ul> <p>Trace entries and replay metadata MAY record:</p> <ul> <li><code>contract_version</code> \u2014 system contract version</li> <li><code>agent_contract_version</code> \u2014 agent output contract version</li> <li><code>model_id</code> / hashes \u2014 stable identifiers for deterministic classification</li> <li>a run fingerprint capturing pipeline definition + config snapshot</li> </ul>"},{"location":"spec/identity/#schema-upgrade-rule","title":"Schema upgrade rule","text":"<p>When reading a trace:</p> <ul> <li>If the schema version is older and an upgrade path exists, tooling SHOULD upgrade in-memory.</li> <li>If an upgrade path does not exist, tooling MUST reject the trace as incompatible.</li> </ul>"},{"location":"spec/identity/#replayability-rule","title":"Replayability rule","text":"<ul> <li>If <code>model_metadata.temperature &gt; 0</code>, the trace MUST be marked <code>NON_REPLAYABLE</code>.</li> <li>Consumers MUST treat replayability as a property of the trace, not a guess about the model.</li> </ul> <p>See also: <code>docs/spec/invariants/determinism.md</code>.</p>"},{"location":"spec/read_this_first/","title":"Read this first (spec)","text":"<p>This section is the normative contract for Bijux Agent: what the system guarantees, what it refuses to do, and how consumers can safely integrate.</p> <p>If you are looking for \u201chow do I run it?\u201d, start in <code>docs/user/usage.md</code> instead.</p>"},{"location":"spec/read_this_first/#how-to-read-the-spec","title":"How to read the spec","text":"<ul> <li>MUST: required for correctness and contract tests</li> <li>SHOULD: strong recommendation; deviations must be explicit</li> <li>MAY: optional</li> </ul> <p>The spec is intentionally narrow: it binds runtime behavior, artifacts, and failure semantics.</p>"},{"location":"spec/read_this_first/#what-is-covered","title":"What is covered","text":"<ul> <li>the canonical pipeline (<code>AuditableDocPipeline</code>)</li> <li>CLI run artifacts (<code>final_result.json</code>, <code>run_trace.json</code>)</li> <li>API v1 execution behavior</li> </ul>"},{"location":"spec/read_this_first/#what-is-not-covered","title":"What is not covered","text":"<ul> <li>model quality</li> <li>latency/cost</li> <li>UI/UX stability</li> <li>provider availability</li> </ul>"},{"location":"spec/read_this_first/#start-here","title":"Start here","text":"<ol> <li><code>docs/spec/system_contract.md</code> \u2014 system-level guarantees and boundaries</li> <li><code>docs/spec/execution_artifacts.md</code> \u2014 what is written and how to interpret it</li> <li><code>docs/spec/failure_model.md</code> and <code>docs/spec/failure_semantics.md</code> \u2014 failure taxonomy and propagation</li> <li><code>docs/spec/invariants/core-invariants.md</code> \u2014 invariants that must remain true across refactors</li> </ol>"},{"location":"spec/refusals/","title":"Refusals and non-features (spec)","text":"<p>These are intentional non-goals. Treat them as stability promises.</p>"},{"location":"spec/refusals/#stateful-behavior","title":"Stateful behavior","text":"<ul> <li>The system MUST NOT persist cross-run memory by default.</li> <li>The system MUST NOT mutate previously written artifacts in-place.</li> </ul>"},{"location":"spec/refusals/#hidden-execution","title":"Hidden execution","text":"<ul> <li>The orchestrator MUST NOT apply silent retries without an explicit failure policy.</li> <li>The system MUST NOT \u201cauto-fix\u201d invalid traces; invalid traces are rejected.</li> </ul>"},{"location":"spec/refusals/#dynamic-composition","title":"Dynamic composition","text":"<ul> <li>The canonical pipeline MUST NOT allow runtime mutation of phase order or transitions.</li> <li>The system MUST NOT accept arbitrary user-defined pipeline graphs at runtime.</li> </ul>"},{"location":"spec/refusals/#misleading-claims","title":"Misleading claims","text":"<ul> <li>Dry-run MUST NOT claim model-derived output.</li> <li>NON_REPLAYABLE traces MUST NOT be presented as deterministically replayable.</li> </ul>"},{"location":"spec/system_contract/","title":"System contract (spec)","text":""},{"location":"spec/system_contract/#scope","title":"Scope","text":"<p>This contract applies to:</p> <ul> <li>the canonical pipeline (<code>AuditableDocPipeline</code>)</li> <li>the CLI driver (<code>python -m bijux_agent.main run \u2026</code>)</li> <li>the API v1 handler (<code>POST /v1/run</code>)</li> <li>produced artifacts (result + trace)</li> </ul> <p>It does not guarantee anything about model \u201ccorrectness\u201d, cost, or latency.</p>"},{"location":"spec/system_contract/#core-guarantees","title":"Core guarantees","text":""},{"location":"spec/system_contract/#canonical-pipeline","title":"Canonical pipeline","text":"<ul> <li>The canonical pipeline structure (phase order and allowed transitions) MUST be fixed at runtime.</li> <li>Runs MUST record enough metadata to identify:</li> <li>the pipeline definition used,</li> <li>the config snapshot used,</li> <li>the runtime version used.</li> </ul>"},{"location":"spec/system_contract/#trace-safety","title":"Trace safety","text":"<ul> <li>A trace MUST record a <code>trace_schema_version</code>.</li> <li>A trace MUST record the runtime version (<code>runtime_version</code>).</li> <li>A trace MUST record <code>model_metadata</code> (provider, model name, temperature, max tokens).</li> </ul>"},{"location":"spec/system_contract/#replayability-classification","title":"Replayability classification","text":"<ul> <li>Traces MUST be marked NON_REPLAYABLE when <code>model_metadata.temperature &gt; 0</code>.</li> <li>Consumers MUST NOT treat a NON_REPLAYABLE trace as eligible for deterministic replay validation.</li> </ul>"},{"location":"spec/system_contract/#fail-fast-behavior","title":"Fail-fast behavior","text":"<p>The system MUST fail fast when:</p> <ul> <li>required trace metadata is missing,</li> <li>failure taxonomy is violated (invalid <code>FailureArtifact</code>),</li> <li>a trace payload cannot be validated against the current schema (or upgraded).</li> </ul>"},{"location":"spec/system_contract/#compatibility-rules","title":"Compatibility rules","text":"<ul> <li>Schema versions are the compatibility gate. Breaking changes require a version bump.</li> <li>Consumers MUST tolerate additional fields in JSON payloads (forward-compatible parsing).</li> </ul> <p>For artifact details: <code>docs/spec/execution_artifacts.md</code>.</p>"},{"location":"spec/vocabulary/","title":"Vocabulary (spec)","text":"<p>This vocabulary defines terms as used in the spec.</p>"},{"location":"spec/vocabulary/#core-terms","title":"Core terms","text":"<ul> <li>Context: the input mapping for a run (goal + input + identifiers).</li> <li>Run: one execution of the canonical pipeline over a context.</li> <li>Phase: a named lifecycle step in the canonical pipeline (e.g. <code>EXECUTE</code>).</li> <li>Trace: <code>run_trace.json</code>, the audit record of a run.</li> <li>Trace entry: one node in the trace with inputs, outputs, status, and metadata.</li> <li>Verdict: the final decision outcome recorded in <code>final_result.json</code>.</li> <li>Epistemic status: the system\u2019s stated certainty level about the verdict.</li> <li>Replayability: a trace classification indicating whether deterministic replay validation is permitted.</li> <li>Fingerprint: a hash derived from pipeline definition + config snapshot used to identify a run.</li> <li>Failure artifact: an immutable structured description of a failure.</li> </ul>"},{"location":"spec/vocabulary/#normative-keywords","title":"Normative keywords","text":"<ul> <li>MUST, SHOULD, MAY: used in the RFC sense (see <code>docs/spec/read_this_first.md</code>).</li> </ul>"},{"location":"spec/agents/agent-contract/","title":"Agent contract (spec)","text":"<p>Agents are workers. They do not orchestrate execution.</p>"},{"location":"spec/agents/agent-contract/#responsibilities","title":"Responsibilities","text":"<p>Agents MAY:</p> <ul> <li>read/transform text</li> <li>produce structured artifacts</li> <li>emit confidence scores</li> </ul> <p>Agents MUST NOT:</p> <ul> <li>manage pipeline lifecycle or transitions</li> <li>persist state across runs (unless explicitly designed and documented)</li> <li>write final artifacts directly (that is <code>FINALIZE</code> responsibility)</li> </ul>"},{"location":"spec/agents/agent-contract/#input-contract","title":"Input contract","text":"<p>Every agent run should be representable as an <code>AgentInputSchema</code>:</p> <ul> <li><code>task_goal</code> (string)</li> <li><code>context_id</code> (string)</li> <li><code>payload</code> (mapping)</li> <li><code>metadata</code> (mapping)</li> </ul>"},{"location":"spec/agents/agent-contract/#output-contract","title":"Output contract","text":"<p>Agent outputs must satisfy <code>AgentOutputSchema</code>:</p> <ul> <li><code>text</code> (non-empty)</li> <li><code>confidence</code> in <code>[0, 1]</code></li> <li><code>metadata.contract_version</code> matching the runtime contract version</li> </ul> <p>This strictness is deliberate: it keeps downstream decisions stable even as prompts or models evolve.</p> <p>(Implementation reference: <code>src/bijux_agent/models/contract.py</code>.)</p>"},{"location":"spec/agents/agent-output/","title":"Agent output expectations (spec)","text":"<p>This document describes what downstream code is allowed to assume about agent outputs.</p>"},{"location":"spec/agents/agent-output/#required-fields","title":"Required fields","text":"<p>An agent output MUST include:</p> <ul> <li><code>text</code>: non-empty string</li> <li><code>confidence</code>: float in <code>[0, 1]</code></li> <li><code>metadata.contract_version</code>: must equal the runtime <code>CONTRACT_VERSION</code></li> </ul>"},{"location":"spec/agents/agent-output/#optional-fields","title":"Optional fields","text":"<p>An agent output MAY include:</p> <ul> <li><code>artifacts</code>: structured payloads for consumers</li> <li><code>scores</code>: named numeric judgments</li> <li>additional metadata (provenance, citations, etc.)</li> </ul>"},{"location":"spec/agents/agent-output/#why-this-is-strict","title":"Why this is strict","text":"<p>Without a stable output contract:</p> <ul> <li>the decision layer becomes brittle,</li> <li>traces become hard to validate,</li> <li>replay tooling cannot safely reason about the run.</li> </ul> <p>If you need a new output shape, extend <code>artifacts</code> rather than weakening the schema.</p>"},{"location":"spec/invariants/architecture-invariants/","title":"Architecture invariants (spec)","text":"<p>These invariants preserve the system boundary and auditability.</p>"},{"location":"spec/invariants/architecture-invariants/#separation-of-concerns","title":"Separation of concerns","text":"<ul> <li>Orchestration MUST live in the pipeline runner, not in agents.</li> <li>Agents MUST be pure workers: given an input contract, return an output contract.</li> </ul>"},{"location":"spec/invariants/architecture-invariants/#artifact-ownership","title":"Artifact ownership","text":"<ul> <li>Final artifacts (<code>final_result.json</code>, <code>run_trace.json</code>) MUST be written by the orchestrator/finalize layer.</li> <li>Agents MUST NOT write or mutate run artifacts directly.</li> </ul>"},{"location":"spec/invariants/architecture-invariants/#statelessness","title":"Statelessness","text":"<ul> <li>The system MUST NOT require persistent state across runs.</li> <li>Any optional caching MUST be explicitly documented and must not change semantics when absent.</li> </ul>"},{"location":"spec/invariants/architecture-invariants/#schema-discipline","title":"Schema discipline","text":"<ul> <li>Trace schema and agent output schema are compatibility gates; breaking changes require version bumps.</li> </ul>"},{"location":"spec/invariants/convergence-guarantees/","title":"Convergence guarantees (spec)","text":"<p>Convergence is a mechanism for stopping iterative refinement when decisions become stable.</p>"},{"location":"spec/invariants/convergence-guarantees/#what-the-system-guarantees","title":"What the system guarantees","text":"<ul> <li>The pipeline MAY iterate multiple times.</li> <li>The final status MUST record:</li> <li>whether the run converged,</li> <li>the number of iterations executed,</li> <li>a convergence reason (when relevant).</li> </ul>"},{"location":"spec/invariants/convergence-guarantees/#what-the-system-does-not-guarantee","title":"What the system does not guarantee","text":"<ul> <li>Convergence does not imply correctness.</li> <li>Convergence thresholds are configuration-dependent and may change between versions.</li> </ul>"},{"location":"spec/invariants/convergence-guarantees/#practical-guidance","title":"Practical guidance","text":"<ul> <li>Prefer convergence strategies that are explainable from artifacts (verdict stability, mixed stability).</li> <li>Avoid \u201chidden\u201d convergence logic that cannot be justified from recorded scores/verdicts.</li> </ul>"},{"location":"spec/invariants/core-invariants/","title":"Core invariants (spec)","text":"<p>These invariants must hold across refactors. If an invariant must change, treat it as a breaking change and bump the relevant schema/version.</p>"},{"location":"spec/invariants/core-invariants/#documentation-invariant","title":"Documentation invariant","text":"<ul> <li>Every <code>docs/**/*.md</code> file MUST be tracked in <code>docs/doc_checksums.json</code>.</li> <li><code>docs/index.md</code> MUST list every tracked documentation file.</li> </ul> <p>(This is enforced by tests.)</p>"},{"location":"spec/invariants/core-invariants/#canonical-pipeline-invariant","title":"Canonical pipeline invariant","text":"<ul> <li>The canonical phase order and allowed transitions MUST remain stable at runtime.</li> <li>Any intentional change MUST be accompanied by a clear versioning decision and updated spec text.</li> </ul>"},{"location":"spec/invariants/core-invariants/#failure-taxonomy-invariant","title":"Failure taxonomy invariant","text":"<ul> <li>Every <code>FailureClass</code> MUST have a profile.</li> <li>Failure artifacts MUST validate against taxonomy profiles.</li> </ul>"},{"location":"spec/invariants/core-invariants/#trace-identity-invariant","title":"Trace identity invariant","text":"<ul> <li>Traces MUST record schema version, runtime version, and model metadata.</li> <li>Replayability MUST be classified in the trace header.</li> </ul> <p>See also:</p> <ul> <li><code>docs/spec/invariants/determinism.md</code></li> <li><code>docs/spec/failure_model.md</code></li> </ul>"},{"location":"spec/invariants/determinism/","title":"Determinism invariants (spec)","text":""},{"location":"spec/invariants/determinism/#replayability-classification","title":"Replayability classification","text":"<ul> <li>If <code>model_metadata.temperature &gt; 0</code>, the trace header MUST set <code>replay_status = NON_REPLAYABLE</code>.</li> <li>If <code>model_metadata.temperature == 0</code>, the trace header SHOULD set <code>replay_status = REPLAYABLE</code>.</li> </ul>"},{"location":"spec/invariants/determinism/#deterministic-snapshots","title":"Deterministic snapshots","text":"<ul> <li>Trace entries MUST be serializable as JSON.</li> <li>Trace entries MUST allow a \u201cdeterministic snapshot\u201d that excludes observational fields (e.g. timestamps).</li> </ul>"},{"location":"spec/invariants/determinism/#observational-fields","title":"Observational fields","text":"<ul> <li>Timestamps are observational and MUST NOT be used as determinism proofs.</li> <li>Adding new observational fields is allowed, but they should be explicitly classified.</li> </ul>"},{"location":"spec/invariants/determinism/#hashing-and-fingerprints","title":"Hashing and fingerprints","text":"<ul> <li>Run fingerprinting MUST hash a stable representation of:</li> <li>pipeline definition</li> <li>config snapshot</li> <li>contract versions</li> <li>Hash computation MUST be order-stable (JSON canonicalization).</li> </ul>"},{"location":"spec/models/deepseek/","title":"DeepSeek backend notes","text":"<p>This document captures backend-specific constraints that affect auditability.</p>"},{"location":"spec/models/deepseek/#key-point","title":"Key point","text":"<p>Providers differ in:</p> <ul> <li>supported parameters (temperature, max tokens),</li> <li>determinism guarantees,</li> <li>error modes and rate limits.</li> </ul> <p>The system\u2019s contract is defined in terms of recorded metadata and artifacts, not in terms of provider behavior.</p>"},{"location":"spec/models/deepseek/#practical-guidance","title":"Practical guidance","text":"<ul> <li>Record <code>model_metadata</code> faithfully (provider/model/temperature/max tokens).</li> <li>Treat provider errors as operational failures (<code>execution_error</code> or <code>resource_exhaustion</code>) depending on the failure mode.</li> <li>Do not claim replayability when sampling is enabled.</li> </ul>"},{"location":"spec/tracing-replay/why-trace-exists/","title":"Why tracing exists","text":"<p>Tracing is not optional overhead; it is the point of the project.</p>"},{"location":"spec/tracing-replay/why-trace-exists/#what-tracing-enables","title":"What tracing enables","text":"<ul> <li>Auditability: decisions are accompanied by structured provenance.</li> <li>Regression detection: compare fingerprints and outcomes across versions.</li> <li>Replay validation: verify that a recorded run satisfies the trace contract.</li> <li>Debugging: correlate phases, agents, and failures without guessing.</li> </ul>"},{"location":"spec/tracing-replay/why-trace-exists/#what-tracing-does-not-claim","title":"What tracing does not claim","text":"<ul> <li>Tracing does not make a model \u201ccorrect\u201d.</li> <li>A REPLAYABLE trace does not guarantee the provider will return identical tokens in the future.</li> <li>A NON_REPLAYABLE trace can still be useful; it just must be labeled honestly.</li> </ul>"},{"location":"spec/tracing-replay/why-trace-exists/#practical-implication","title":"Practical implication","text":"<p>If you remove trace metadata, you remove the system\u2019s ability to prove what happened. The code is expected to fail fast rather than emit unverifiable artifacts.</p>"},{"location":"user/reading_paths/","title":"Reading paths","text":"<p>Pick the track that matches what you are trying to do.</p>"},{"location":"user/reading_paths/#i-just-want-to-run-it-cli","title":"I just want to run it (CLI)","text":"<ol> <li><code>docs/user/usage.md</code></li> <li><code>docs/overview/concepts.md</code> (mental model + artifacts)</li> <li><code>docs/spec/execution_artifacts.md</code> (what files are produced and what they mean)</li> </ol>"},{"location":"user/reading_paths/#i-want-to-embed-it-http-api","title":"I want to embed it (HTTP API)","text":"<ol> <li><code>docs/api/index.md</code></li> <li><code>docs/spec/system_contract.md</code></li> <li><code>docs/spec/execution_contracts.md</code></li> <li><code>docs/spec/failure_model.md</code></li> </ol>"},{"location":"user/reading_paths/#i-want-the-formal-guarantees-spec","title":"I want the formal guarantees (spec)","text":"<ol> <li><code>docs/spec/read_this_first.md</code></li> <li><code>docs/spec/system_contract.md</code></li> <li><code>docs/spec/execution_guarantees.md</code></li> <li><code>docs/spec/execution_artifacts.md</code></li> <li><code>docs/spec/failure_model.md</code> and <code>docs/spec/failure_semantics.md</code></li> <li><code>docs/spec/invariants/*</code></li> </ol>"},{"location":"user/reading_paths/#i-maintain-the-repository","title":"I maintain the repository","text":"<ol> <li><code>docs/maintainer/spec.md</code> (entry point)</li> <li><code>docs/maintainer/tooling.md</code> (commands + CI expectations)</li> <li><code>docs/maintainer/testing.md</code></li> <li><code>docs/maintainer/documentation-invariant.md</code></li> </ol>"},{"location":"user/usage/","title":"Usage","text":"<p>Bijux Agent is a deterministic, auditable document-processing pipeline with a CLI and an optional HTTP API.</p>"},{"location":"user/usage/#install","title":"Install","text":"<p>Development (recommended):</p> <pre><code>make bootstrap\n</code></pre> <p>Minimal (no dev tooling):</p> <pre><code>python -m pip install -e .\n</code></pre>"},{"location":"user/usage/#configure-api-keys","title":"Configure API keys","text":"<p>The CLI currently validates that all providers below are configured before it will run:</p> <ul> <li><code>OPENAI_API_KEY</code></li> <li><code>ANTHROPIC_API_KEY</code></li> <li><code>HUGGINGFACE_API_KEY</code></li> <li><code>DEEPSEEK_API_KEY</code></li> </ul> <p>Put them in a <code>.env</code> file at the repository root, or export them in your shell.</p>"},{"location":"user/usage/#run","title":"Run","text":"<p>Process a single file:</p> <pre><code>python -m bijux_agent.main run path/to/file.txt --out artifacts/run1 --config config/config.yml\n</code></pre> <p>Process a directory (non-recursive; files directly under the directory):</p> <pre><code>python -m bijux_agent.main run path/to/dir --out artifacts/run1 --config config/config.yml\n</code></pre> <p>Dry-run (no model calls; validates discovery + wiring only):</p> <pre><code>python -m bijux_agent.main run path/to/file.txt --out artifacts/run1 --config config/config.yml --dry-run\n</code></pre>"},{"location":"user/usage/#outputs","title":"Outputs","text":"<p><code>--out &lt;DIR&gt;</code> is treated as a single run directory. The CLI writes:</p> <ul> <li><code>&lt;DIR&gt;/result/final_result.json</code> \u2014 compact, human-friendly verdict summary</li> <li><code>&lt;DIR&gt;/trace/run_trace.json</code> \u2014 machine-checkable run trace (for auditing/replay tooling)</li> <li>logs under the configured <code>logging.log_dir</code> (from your YAML config)</li> </ul> <p>If exactly one file is processed and succeeds, the CLI also prints the computed <code>result</code> JSON to stdout.</p>"},{"location":"user/usage/#replay","title":"Replay","text":"<p>Replay is a verification tool: it reads a trace and reports whether the recorded run is internally consistent.</p> <pre><code>python -m bijux_agent.main replay artifacts/run1/trace/run_trace.json\n</code></pre> <p>Replay does not re-run models.</p>"},{"location":"user/usage/#configuration-quick-reference","title":"Configuration quick reference","text":"<p>The CLI reads the YAML config passed via <code>--config</code>.</p> <p>Minimum required keys for trace construction:</p> <pre><code>task_goal: \"summarize this document\"\nmodel_metadata:\n  provider: \"local\"\n  model_name: \"auditable-doc-pipeline\"\n  temperature: 0.0\n  max_tokens: 512\n</code></pre> <p>For the normative contract (what is guaranteed vs best-effort), see <code>docs/spec/read_this_first.md</code>.</p>"},{"location":"user/usage/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\u201cMissing API keys \u2026\u201d: the current CLI is intentionally strict. Configure all keys or change <code>bijux_agent.config.env.validate_keys()</code> to validate only the selected backend.</li> <li>Empty input directory: the CLI only processes files directly under the directory; it does not recurse.</li> <li>Where are the logs?: check <code>logging.log_dir</code> in the YAML config (default in <code>config/config.yml</code>).</li> </ul>"}]}